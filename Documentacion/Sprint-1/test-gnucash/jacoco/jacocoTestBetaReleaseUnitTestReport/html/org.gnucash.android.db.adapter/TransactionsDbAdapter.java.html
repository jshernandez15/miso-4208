<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="es"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TransactionsDbAdapter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">app</a> &gt; <a href="index.source.html" class="el_package">org.gnucash.android.db.adapter</a> &gt; <span class="el_source">TransactionsDbAdapter.java</span></div><h1>TransactionsDbAdapter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2012 - 2015 Ngewi Fet &lt;ngewif@gmail.com&gt;
 * Copyright (c) 2014 Yongxin Wang &lt;fefe.wyx@gmail.com&gt;
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.gnucash.android.db.adapter;

import android.content.ContentValues;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteQueryBuilder;
import android.database.sqlite.SQLiteStatement;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.text.TextUtils;
import android.util.Log;

import com.crashlytics.android.Crashlytics;

import org.gnucash.android.app.GnuCashApplication;
import org.gnucash.android.model.AccountType;
import org.gnucash.android.model.Commodity;
import org.gnucash.android.model.Money;
import org.gnucash.android.model.Split;
import org.gnucash.android.model.Transaction;
import org.gnucash.android.util.TimestampHelper;

import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;

import static org.gnucash.android.db.DatabaseSchema.AccountEntry;
import static org.gnucash.android.db.DatabaseSchema.ScheduledActionEntry;
import static org.gnucash.android.db.DatabaseSchema.SplitEntry;
import static org.gnucash.android.db.DatabaseSchema.TransactionEntry;

/**
 * Manages persistence of {@link Transaction}s in the database
 * Handles adding, modifying and deleting of transaction records.
 * @author Ngewi Fet &lt;ngewif@gmail.com&gt; 
 * @author Yongxin Wang &lt;fefe.wyx@gmail.com&gt;
 * @author Oleksandr Tyshkovets &lt;olexandr.tyshkovets@gmail.com&gt;
 */
public class TransactionsDbAdapter extends DatabaseAdapter&lt;Transaction&gt; {

    private final SplitsDbAdapter mSplitsDbAdapter;

    private final CommoditiesDbAdapter mCommoditiesDbAdapter;

    /**
     * Overloaded constructor. Creates adapter for already open db
     * @param db SQlite db instance
     */
    public TransactionsDbAdapter(SQLiteDatabase db, SplitsDbAdapter splitsDbAdapter) {
<span class="nc" id="L68">        super(db, TransactionEntry.TABLE_NAME, new String[]{</span>
                TransactionEntry.COLUMN_DESCRIPTION,
                TransactionEntry.COLUMN_NOTES,
                TransactionEntry.COLUMN_TIMESTAMP,
                TransactionEntry.COLUMN_EXPORTED,
                TransactionEntry.COLUMN_CURRENCY,
                TransactionEntry.COLUMN_COMMODITY_UID,
                TransactionEntry.COLUMN_CREATED_AT,
                TransactionEntry.COLUMN_SCHEDX_ACTION_UID,
                TransactionEntry.COLUMN_TEMPLATE
        });
<span class="nc" id="L79">        mSplitsDbAdapter = splitsDbAdapter;</span>
<span class="nc" id="L80">        mCommoditiesDbAdapter = new CommoditiesDbAdapter(db);</span>
<span class="nc" id="L81">    }</span>

    /**
     * Returns an application-wide instance of the database adapter
     * @return Transaction database adapter
     */
    public static TransactionsDbAdapter getInstance(){
<span class="nc" id="L88">        return GnuCashApplication.getTransactionDbAdapter();</span>
    }

    public SplitsDbAdapter getSplitDbAdapter() {
<span class="nc" id="L92">        return mSplitsDbAdapter;</span>
    }

    /**
	 * Adds an transaction to the database. 
	 * If a transaction already exists in the database with the same unique ID, 
	 * then the record will just be updated instead
	 * @param transaction {@link Transaction} to be inserted to database
	 */
    @Override
	public void addRecord(@NonNull Transaction transaction, UpdateMethod updateMethod){
<span class="nc" id="L103">        Log.d(LOG_TAG, &quot;Adding transaction to the db via &quot; + updateMethod.name());</span>
<span class="nc" id="L104">        mDb.beginTransaction();</span>
        try {
<span class="nc" id="L106">            Split imbalanceSplit = transaction.createAutoBalanceSplit();</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">            if (imbalanceSplit != null){</span>
<span class="nc" id="L108">                String imbalanceAccountUID = new AccountsDbAdapter(mDb, this)</span>
<span class="nc" id="L109">                        .getOrCreateImbalanceAccountUID(transaction.getCommodity());</span>
<span class="nc" id="L110">                imbalanceSplit.setAccountUID(imbalanceAccountUID);</span>
            }
<span class="nc" id="L112">            super.addRecord(transaction, updateMethod);</span>

<span class="nc" id="L114">            Log.d(LOG_TAG, &quot;Adding splits for transaction&quot;);</span>
<span class="nc" id="L115">            ArrayList&lt;String&gt; splitUIDs = new ArrayList&lt;&gt;(transaction.getSplits().size());</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">            for (Split split : transaction.getSplits()) {</span>
<span class="nc" id="L117">                Log.d(LOG_TAG, &quot;Replace transaction split in db&quot;);</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">                if (imbalanceSplit == split) {</span>
<span class="nc" id="L119">                    mSplitsDbAdapter.addRecord(split, UpdateMethod.insert);</span>
                } else {
<span class="nc" id="L121">                    mSplitsDbAdapter.addRecord(split, updateMethod);</span>
                }
<span class="nc" id="L123">                splitUIDs.add(split.getUID());</span>
<span class="nc" id="L124">            }</span>
<span class="nc" id="L125">            Log.d(LOG_TAG, transaction.getSplits().size() + &quot; splits added&quot;);</span>

<span class="nc" id="L127">            long deleted = mDb.delete(SplitEntry.TABLE_NAME,</span>
                    SplitEntry.COLUMN_TRANSACTION_UID + &quot; = ? AND &quot;
<span class="nc" id="L129">                            + SplitEntry.COLUMN_UID + &quot; NOT IN ('&quot; + TextUtils.join(&quot;' , '&quot;, splitUIDs) + &quot;')&quot;,</span>
<span class="nc" id="L130">                    new String[]{transaction.getUID()});</span>
<span class="nc" id="L131">            Log.d(LOG_TAG, deleted + &quot; splits deleted&quot;);</span>

<span class="nc" id="L133">            mDb.setTransactionSuccessful();</span>
<span class="nc" id="L134">        } catch (SQLException sqlEx) {</span>
<span class="nc" id="L135">            Log.e(LOG_TAG, sqlEx.getMessage());</span>
<span class="nc" id="L136">            Crashlytics.logException(sqlEx);</span>
        } finally {
<span class="nc" id="L138">            mDb.endTransaction();</span>
<span class="nc" id="L139">        }</span>
<span class="nc" id="L140">	}</span>

    /**
     * Adds an several transactions to the database.
     * If a transaction already exists in the database with the same unique ID,
     * then the record will just be updated instead. Recurrence Transactions will not
     * be inserted, instead schedule Transaction would be called. If an exception
     * occurs, no transaction would be inserted.
     * @param transactionList {@link Transaction} transactions to be inserted to database
     * @return Number of transactions inserted
     */
    @Override
    public long bulkAddRecords(@NonNull List&lt;Transaction&gt; transactionList, UpdateMethod updateMethod){
<span class="nc" id="L153">        long start = System.nanoTime();</span>
<span class="nc" id="L154">        long rowInserted = super.bulkAddRecords(transactionList, updateMethod);</span>
<span class="nc" id="L155">        long end = System.nanoTime();</span>
<span class="nc" id="L156">        Log.d(getClass().getSimpleName(), String.format(&quot;bulk add transaction time %d &quot;, end - start));</span>
<span class="nc" id="L157">        List&lt;Split&gt; splitList = new ArrayList&lt;&gt;(transactionList.size()*3);</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">        for (Transaction transaction : transactionList) {</span>
<span class="nc" id="L159">            splitList.addAll(transaction.getSplits());</span>
<span class="nc" id="L160">        }</span>
<span class="nc bnc" id="L161" title="All 4 branches missed.">        if (rowInserted != 0 &amp;&amp; !splitList.isEmpty()) {</span>
            try {
<span class="nc" id="L163">                start = System.nanoTime();</span>
<span class="nc" id="L164">                long nSplits = mSplitsDbAdapter.bulkAddRecords(splitList, updateMethod);</span>
<span class="nc" id="L165">                Log.d(LOG_TAG, String.format(&quot;%d splits inserted in %d ns&quot;, nSplits, System.nanoTime()-start));</span>
            }
            finally {
<span class="nc" id="L168">                SQLiteStatement deleteEmptyTransaction = mDb.compileStatement(&quot;DELETE FROM &quot; +</span>
                        TransactionEntry.TABLE_NAME + &quot; WHERE NOT EXISTS ( SELECT * FROM &quot; +
                        SplitEntry.TABLE_NAME +
                        &quot; WHERE &quot; + TransactionEntry.TABLE_NAME + &quot;.&quot; + TransactionEntry.COLUMN_UID +
                        &quot; = &quot; + SplitEntry.TABLE_NAME + &quot;.&quot; + SplitEntry.COLUMN_TRANSACTION_UID + &quot; ) &quot;);
<span class="nc" id="L173">                deleteEmptyTransaction.execute();</span>
<span class="nc" id="L174">            }</span>
        }
<span class="nc" id="L176">        return rowInserted;</span>
    }

    @Override
    protected @NonNull SQLiteStatement setBindings(@NonNull SQLiteStatement stmt, @NonNull Transaction transaction) {
<span class="nc" id="L181">        stmt.clearBindings();</span>
<span class="nc" id="L182">        stmt.bindString(1, transaction.getDescription());</span>
<span class="nc" id="L183">        stmt.bindString(2, transaction.getNote());</span>
<span class="nc" id="L184">        stmt.bindLong(3, transaction.getTimeMillis());</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">        stmt.bindLong(4, transaction.isExported() ? 1 : 0);</span>
<span class="nc" id="L186">        stmt.bindString(5, transaction.getCurrencyCode());</span>
<span class="nc" id="L187">        stmt.bindString(6, transaction.getCommodity().getUID());</span>
<span class="nc" id="L188">        stmt.bindString(7, TimestampHelper.getUtcStringFromTimestamp(transaction.getCreatedTimestamp()));</span>

<span class="nc bnc" id="L190" title="All 2 branches missed.">        if (transaction.getScheduledActionUID() == null)</span>
<span class="nc" id="L191">            stmt.bindNull(8);</span>
        else
<span class="nc" id="L193">            stmt.bindString(8, transaction.getScheduledActionUID());</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">        stmt.bindLong(9, transaction.isTemplate() ? 1 : 0);</span>
<span class="nc" id="L195">        stmt.bindString(10, transaction.getUID());</span>

<span class="nc" id="L197">        return stmt;</span>
    }

    /**
	 * Returns a cursor to a set of all transactions which have a split belonging to the accound with unique ID
	 * &lt;code&gt;accountUID&lt;/code&gt;.
	 * @param accountUID UID of the account whose transactions are to be retrieved
	 * @return Cursor holding set of transactions for particular account
     * @throws java.lang.IllegalArgumentException if the accountUID is null
	 */
	public Cursor fetchAllTransactionsForAccount(String accountUID){
<span class="nc" id="L208">        SQLiteQueryBuilder queryBuilder = new SQLiteQueryBuilder();</span>
<span class="nc" id="L209">        queryBuilder.setTables(TransactionEntry.TABLE_NAME</span>
                + &quot; INNER JOIN &quot; + SplitEntry.TABLE_NAME + &quot; ON &quot;
                + TransactionEntry.TABLE_NAME + &quot;.&quot; + TransactionEntry.COLUMN_UID + &quot; = &quot;
                + SplitEntry.TABLE_NAME + &quot;.&quot; + SplitEntry.COLUMN_TRANSACTION_UID);
<span class="nc" id="L213">        queryBuilder.setDistinct(true);</span>
<span class="nc" id="L214">        String[] projectionIn = new String[]{TransactionEntry.TABLE_NAME + &quot;.*&quot;};</span>
<span class="nc" id="L215">        String selection = SplitEntry.TABLE_NAME + &quot;.&quot; + SplitEntry.COLUMN_ACCOUNT_UID + &quot; = ?&quot;</span>
                + &quot; AND &quot; + TransactionEntry.TABLE_NAME + &quot;.&quot; + TransactionEntry.COLUMN_TEMPLATE + &quot; = 0&quot;;
<span class="nc" id="L217">        String[] selectionArgs = new String[]{accountUID};</span>
<span class="nc" id="L218">        String sortOrder = TransactionEntry.TABLE_NAME + &quot;.&quot; + TransactionEntry.COLUMN_TIMESTAMP + &quot; DESC&quot;;</span>

<span class="nc" id="L220">        return queryBuilder.query(mDb, projectionIn, selection, selectionArgs, null, null, sortOrder);</span>
    }

    /**
     * Returns a cursor to all scheduled transactions which have at least one split in the account
     * &lt;p&gt;This is basically a set of all template transactions for this account&lt;/p&gt;
     * @param accountUID GUID of account
     * @return Cursor with set of transactions
     */
    public Cursor fetchScheduledTransactionsForAccount(String accountUID){
<span class="nc" id="L230">        SQLiteQueryBuilder queryBuilder = new SQLiteQueryBuilder();</span>
<span class="nc" id="L231">        queryBuilder.setTables(TransactionEntry.TABLE_NAME</span>
                + &quot; INNER JOIN &quot; + SplitEntry.TABLE_NAME + &quot; ON &quot;
                + TransactionEntry.TABLE_NAME + &quot;.&quot; + TransactionEntry.COLUMN_UID + &quot; = &quot;
                + SplitEntry.TABLE_NAME + &quot;.&quot; + SplitEntry.COLUMN_TRANSACTION_UID);
<span class="nc" id="L235">        queryBuilder.setDistinct(true);</span>
<span class="nc" id="L236">        String[] projectionIn = new String[]{TransactionEntry.TABLE_NAME + &quot;.*&quot;};</span>
<span class="nc" id="L237">        String selection = SplitEntry.TABLE_NAME + &quot;.&quot; + SplitEntry.COLUMN_ACCOUNT_UID + &quot; = ?&quot;</span>
                + &quot; AND &quot; + TransactionEntry.TABLE_NAME + &quot;.&quot; + TransactionEntry.COLUMN_TEMPLATE + &quot; = 1&quot;;
<span class="nc" id="L239">        String[] selectionArgs = new String[]{accountUID};</span>
<span class="nc" id="L240">        String sortOrder = TransactionEntry.TABLE_NAME + &quot;.&quot; + TransactionEntry.COLUMN_TIMESTAMP + &quot; DESC&quot;;</span>

<span class="nc" id="L242">        return queryBuilder.query(mDb, projectionIn, selection, selectionArgs, null, null, sortOrder);</span>
    }

    /**
     * Deletes all transactions which contain a split in the account.
     * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt;As long as the transaction has one split which belongs to the account {@code accountUID},
     * it will be deleted. The other splits belonging to the transaction will also go away&lt;/p&gt;
     * @param accountUID GUID of the account
     */
    public void deleteTransactionsForAccount(String accountUID){
<span class="nc" id="L252">        String rawDeleteQuery = &quot;DELETE FROM &quot; + TransactionEntry.TABLE_NAME + &quot; WHERE &quot; + TransactionEntry.COLUMN_UID + &quot; IN &quot;</span>
                + &quot; (SELECT &quot; + SplitEntry.COLUMN_TRANSACTION_UID + &quot; FROM &quot; + SplitEntry.TABLE_NAME + &quot; WHERE &quot;
                + SplitEntry.COLUMN_ACCOUNT_UID + &quot; = ?)&quot;;
<span class="nc" id="L255">        mDb.execSQL(rawDeleteQuery, new String[]{accountUID});</span>
<span class="nc" id="L256">    }</span>

    /**
     * Deletes all transactions which have no splits associated with them
     * @return Number of records deleted
     */
    public int deleteTransactionsWithNoSplits(){
<span class="nc" id="L263">        return mDb.delete(</span>
                TransactionEntry.TABLE_NAME,
                &quot;NOT EXISTS ( SELECT * FROM &quot; + SplitEntry.TABLE_NAME +
                        &quot; WHERE &quot; + TransactionEntry.TABLE_NAME + &quot;.&quot; + TransactionEntry.COLUMN_UID +
                        &quot; = &quot; + SplitEntry.TABLE_NAME + &quot;.&quot; + SplitEntry.COLUMN_TRANSACTION_UID + &quot; ) &quot;,
                null
        );
    }

    /**
     * Fetches all recurring transactions from the database.
     * &lt;p&gt;Recurring transactions are the transaction templates which have an entry in the scheduled events table&lt;/p&gt;
     * @return Cursor holding set of all recurring transactions
     */
    public Cursor fetchAllScheduledTransactions(){
<span class="nc" id="L278">        SQLiteQueryBuilder queryBuilder = new SQLiteQueryBuilder();</span>
<span class="nc" id="L279">        queryBuilder.setTables(TransactionEntry.TABLE_NAME + &quot; INNER JOIN &quot; + ScheduledActionEntry.TABLE_NAME + &quot; ON &quot;</span>
                + TransactionEntry.TABLE_NAME + &quot;.&quot; + TransactionEntry.COLUMN_UID + &quot; = &quot;
                + ScheduledActionEntry.TABLE_NAME + &quot;.&quot; + ScheduledActionEntry.COLUMN_ACTION_UID);

<span class="nc" id="L283">        String[] projectionIn = new String[]{TransactionEntry.TABLE_NAME + &quot;.*&quot;,</span>
                ScheduledActionEntry.TABLE_NAME+&quot;.&quot;+ScheduledActionEntry.COLUMN_UID + &quot; AS &quot; + &quot;origin_scheduled_action_uid&quot;};
<span class="nc" id="L285">        String sortOrder = TransactionEntry.TABLE_NAME + &quot;.&quot; + TransactionEntry.COLUMN_DESCRIPTION + &quot; ASC&quot;;</span>
//        queryBuilder.setDistinct(true);

<span class="nc" id="L288">        return queryBuilder.query(mDb, projectionIn, null, null, null, null, sortOrder);</span>
    }

	/**
	 * Returns list of all transactions for account with UID &lt;code&gt;accountUID&lt;/code&gt;
	 * @param accountUID UID of account whose transactions are to be retrieved
	 * @return List of {@link Transaction}s for account with UID &lt;code&gt;accountUID&lt;/code&gt;
	 */
    public List&lt;Transaction&gt; getAllTransactionsForAccount(String accountUID){
<span class="nc" id="L297">		Cursor c = fetchAllTransactionsForAccount(accountUID);</span>
<span class="nc" id="L298">		ArrayList&lt;Transaction&gt; transactionsList = new ArrayList&lt;&gt;();</span>
        try {
<span class="nc bnc" id="L300" title="All 2 branches missed.">            while (c.moveToNext()) {</span>
<span class="nc" id="L301">                transactionsList.add(buildModelInstance(c));</span>
            }
        } finally {
<span class="nc" id="L304">            c.close();</span>
<span class="nc" id="L305">        }</span>
<span class="nc" id="L306">		return transactionsList;</span>
	}

    /**
     * Returns all transaction instances in the database.
     * @return List of all transactions
     */
    public List&lt;Transaction&gt; getAllTransactions(){
<span class="nc" id="L314">        Cursor cursor = fetchAllRecords();</span>
<span class="nc" id="L315">        List&lt;Transaction&gt; transactions = new ArrayList&lt;Transaction&gt;();</span>
        try {
<span class="nc bnc" id="L317" title="All 2 branches missed.">            while (cursor.moveToNext()) {</span>
<span class="nc" id="L318">                transactions.add(buildModelInstance(cursor));</span>
            }
        } finally {
<span class="nc" id="L321">            cursor.close();</span>
<span class="nc" id="L322">        }</span>
<span class="nc" id="L323">        return transactions;</span>
    }

    public Cursor fetchTransactionsWithSplits(String [] columns, @Nullable String where, @Nullable String[] whereArgs, @Nullable String orderBy) {
<span class="nc" id="L327">        return mDb.query(TransactionEntry.TABLE_NAME + &quot; , &quot; + SplitEntry.TABLE_NAME +</span>
                        &quot; ON &quot; + TransactionEntry.TABLE_NAME + &quot;.&quot; + TransactionEntry.COLUMN_UID +
                        &quot; = &quot; + SplitEntry.TABLE_NAME + &quot;.&quot; + SplitEntry.COLUMN_TRANSACTION_UID +
                        &quot; , trans_extra_info ON trans_extra_info.trans_acct_t_uid = &quot; + TransactionEntry.TABLE_NAME + &quot;.&quot; + TransactionEntry.COLUMN_UID ,
                columns, where, whereArgs, null, null,
                orderBy);
    }

    public Cursor fetchTransactionsWithSplitsWithTransactionAccount(String [] columns, String where, String[] whereArgs, String orderBy) {
        // table is :
        // trans_split_acct , trans_extra_info ON trans_extra_info.trans_acct_t_uid = transactions_uid ,
        // accounts AS account1 ON account1.uid = trans_extra_info.trans_acct_a_uid
        //
        // views effectively simplified this query
        //
        // account1 provides information for the grouped account. Splits from the grouped account
        // can be eliminated with a WHERE clause. Transactions in QIF can be auto balanced.
        //
        // Account, transaction and split Information can be retrieve in a single query.
<span class="nc" id="L346">        return mDb.query(</span>
                &quot;trans_split_acct , trans_extra_info ON trans_extra_info.trans_acct_t_uid = trans_split_acct.&quot; +
                TransactionEntry.TABLE_NAME + &quot;_&quot; + TransactionEntry.COLUMN_UID + &quot; , &quot; +
                AccountEntry.TABLE_NAME + &quot; AS account1 ON account1.&quot; + AccountEntry.COLUMN_UID +
                &quot; = trans_extra_info.trans_acct_a_uid&quot;,
                columns, where, whereArgs, null, null , orderBy);
    }

    /**
     * Return number of transactions in the database (excluding templates)
     * @return Number of transactions
     */
    public long getRecordsCount() {
<span class="nc" id="L359">        String queryCount = &quot;SELECT COUNT(*) FROM &quot; + TransactionEntry.TABLE_NAME +</span>
                &quot; WHERE &quot; + TransactionEntry.COLUMN_TEMPLATE + &quot; =0&quot;;
<span class="nc" id="L361">        Cursor cursor = mDb.rawQuery(queryCount, null);</span>
        try {
<span class="nc" id="L363">            cursor.moveToFirst();</span>
<span class="nc" id="L364">            return cursor.getLong(0);</span>
        } finally {
<span class="nc" id="L366">            cursor.close();</span>
        }
    }

    /**
     * Returns the number of transactions in the database which fulfill the conditions
     * @param where SQL WHERE clause without the &quot;WHERE&quot; itself
     * @param whereArgs Arguments to substitute question marks for
     * @return Number of records in the databases
     */
    public long getRecordsCount(@Nullable String where, @Nullable String[] whereArgs) {
<span class="nc" id="L377">        Cursor cursor = mDb.query(true, TransactionEntry.TABLE_NAME + &quot; , trans_extra_info ON &quot;</span>
                        + TransactionEntry.TABLE_NAME + &quot;.&quot; + TransactionEntry.COLUMN_UID
                        + &quot; = trans_extra_info.trans_acct_t_uid&quot;,
                new String[]{&quot;COUNT(*)&quot;},
                where,
                whereArgs,
                null,
                null,
                null,
                null);
        try{
<span class="nc" id="L388">            cursor.moveToFirst();</span>
<span class="nc" id="L389">            return cursor.getLong(0);</span>
        } finally {
<span class="nc" id="L391">            cursor.close();</span>
        }
    }

	/**
	 * Builds a transaction instance with the provided cursor.
	 * The cursor should already be pointing to the transaction record in the database
	 * @param c Cursor pointing to transaction record in database
	 * @return {@link Transaction} object constructed from database record
	 */
    @Override
    public Transaction buildModelInstance(@NonNull final Cursor c){
<span class="nc" id="L403">		String name   = c.getString(c.getColumnIndexOrThrow(TransactionEntry.COLUMN_DESCRIPTION));</span>
<span class="nc" id="L404">		Transaction transaction = new Transaction(name);</span>
<span class="nc" id="L405">        populateBaseModelAttributes(c, transaction);</span>

<span class="nc" id="L407">		transaction.setTime(c.getLong(c.getColumnIndexOrThrow(TransactionEntry.COLUMN_TIMESTAMP)));</span>
<span class="nc" id="L408">		transaction.setNote(c.getString(c.getColumnIndexOrThrow(TransactionEntry.COLUMN_NOTES)));</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">		transaction.setExported(c.getInt(c.getColumnIndexOrThrow(TransactionEntry.COLUMN_EXPORTED)) == 1);</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">		transaction.setTemplate(c.getInt(c.getColumnIndexOrThrow(TransactionEntry.COLUMN_TEMPLATE)) == 1);</span>
<span class="nc" id="L411">        String currencyCode = c.getString(c.getColumnIndexOrThrow(TransactionEntry.COLUMN_CURRENCY));</span>
<span class="nc" id="L412">        transaction.setCommodity(mCommoditiesDbAdapter.getCommodity(currencyCode));</span>
<span class="nc" id="L413">        transaction.setScheduledActionUID(c.getString(c.getColumnIndexOrThrow(TransactionEntry.COLUMN_SCHEDX_ACTION_UID)));</span>
<span class="nc" id="L414">        long transactionID = c.getLong(c.getColumnIndexOrThrow(TransactionEntry._ID));</span>
<span class="nc" id="L415">        transaction.setSplits(mSplitsDbAdapter.getSplitsForTransaction(transactionID));</span>

<span class="nc" id="L417">		return transaction;</span>
	}

    /**
     * Returns the transaction balance for the transaction for the specified account.
     * &lt;p&gt;We consider only those splits which belong to this account&lt;/p&gt;
     * @param transactionUID GUID of the transaction
     * @param accountUID GUID of the account
     * @return {@link org.gnucash.android.model.Money} balance of the transaction for that account
     */
    public Money getBalance(String transactionUID, String accountUID){
<span class="nc" id="L428">        List&lt;Split&gt; splitList = mSplitsDbAdapter.getSplitsForTransactionInAccount(</span>
                transactionUID, accountUID);

<span class="nc" id="L431">        return Transaction.computeBalance(accountUID, splitList);</span>
    }

    /**
	 * Assigns transaction with id &lt;code&gt;rowId&lt;/code&gt; to account with id &lt;code&gt;accountId&lt;/code&gt;
	 * @param transactionUID GUID of the transaction
     * @param srcAccountUID GUID of the account from which the transaction is to be moved
	 * @param dstAccountUID GUID of the account to which the transaction will be assigned
	 * @return Number of transactions splits affected
	 */
	public int moveTransaction(String transactionUID, String srcAccountUID, String dstAccountUID){
<span class="nc" id="L442">		Log.i(LOG_TAG, &quot;Moving transaction ID &quot; + transactionUID</span>
                + &quot; splits from &quot; + srcAccountUID + &quot; to account &quot; + dstAccountUID);

<span class="nc" id="L445">		List&lt;Split&gt; splits = mSplitsDbAdapter.getSplitsForTransactionInAccount(transactionUID, srcAccountUID);</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">        for (Split split : splits) {</span>
<span class="nc" id="L447">            split.setAccountUID(dstAccountUID);</span>
<span class="nc" id="L448">        }</span>
<span class="nc" id="L449">        mSplitsDbAdapter.bulkAddRecords(splits, UpdateMethod.update);</span>
<span class="nc" id="L450">        return splits.size();</span>
	}

    /**
     * Returns the number of transactions belonging to an account
     * @param accountUID GUID of the account
     * @return Number of transactions with splits in the account
     */
    public int getTransactionsCount(String accountUID){
<span class="nc" id="L459">        Cursor cursor = fetchAllTransactionsForAccount(accountUID);</span>
<span class="nc" id="L460">        int count = 0;</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">        if (cursor == null)</span>
<span class="nc" id="L462">            return count;</span>
        else {
<span class="nc" id="L464">            count = cursor.getCount();</span>
<span class="nc" id="L465">            cursor.close();</span>
        }
<span class="nc" id="L467">        return count;</span>
    }

    /**
     * Returns the number of template transactions in the database
     * @return Number of template transactions
     */
    public long getTemplateTransactionsCount(){
<span class="nc" id="L475">        String sql = &quot;SELECT COUNT(*) FROM &quot; + TransactionEntry.TABLE_NAME</span>
                + &quot; WHERE &quot; + TransactionEntry.COLUMN_TEMPLATE + &quot;=1&quot;;
<span class="nc" id="L477">        SQLiteStatement statement = mDb.compileStatement(sql);</span>
<span class="nc" id="L478">        return statement.simpleQueryForLong();</span>
    }

    /**
     * Returns a list of all scheduled transactions in the database
     * @return List of all scheduled transactions
     */
    public List&lt;Transaction&gt; getScheduledTransactionsForAccount(String accountUID){
<span class="nc" id="L486">        Cursor cursor = fetchScheduledTransactionsForAccount(accountUID);</span>
<span class="nc" id="L487">        List&lt;Transaction&gt; scheduledTransactions = new ArrayList&lt;&gt;();</span>
        try {
<span class="nc bnc" id="L489" title="All 2 branches missed.">            while (cursor.moveToNext()) {</span>
<span class="nc" id="L490">                scheduledTransactions.add(buildModelInstance(cursor));</span>
            }
<span class="nc" id="L492">            return scheduledTransactions;</span>
        } finally {
<span class="nc" id="L494">            cursor.close();</span>
        }
    }

    /**
     * Returns the number of splits for the transaction in the database
     * @param transactionUID GUID of the transaction
     * @return Number of splits belonging to the transaction
     */
    public long getSplitCount(@NonNull String transactionUID){
<span class="nc bnc" id="L504" title="All 2 branches missed.">        if (transactionUID == null)</span>
<span class="nc" id="L505">            return 0;</span>
<span class="nc" id="L506">        String sql = &quot;SELECT COUNT(*) FROM &quot; + SplitEntry.TABLE_NAME</span>
                + &quot; WHERE &quot; + SplitEntry.COLUMN_TRANSACTION_UID + &quot;= '&quot; + transactionUID + &quot;'&quot;;
<span class="nc" id="L508">        SQLiteStatement statement = mDb.compileStatement(sql);</span>
<span class="nc" id="L509">        return statement.simpleQueryForLong();</span>
    }

    /**
     * Returns a cursor to transactions whose name (UI: description) start with the &lt;code&gt;prefix&lt;/code&gt;
     * &lt;p&gt;This method is used for autocomplete suggestions when creating new transactions. &lt;br/&gt;
     * The suggestions are either transactions which have at least one split with {@code accountUID} or templates.&lt;/p&gt;
     * @param prefix Starting characters of the transaction name
     * @param accountUID GUID of account within which to search for transactions
     * @return Cursor to the data set containing all matching transactions
     */
    public Cursor fetchTransactionSuggestions(String prefix, String accountUID){
<span class="nc" id="L521">        SQLiteQueryBuilder queryBuilder = new SQLiteQueryBuilder();</span>
<span class="nc" id="L522">        queryBuilder.setTables(TransactionEntry.TABLE_NAME</span>
                + &quot; INNER JOIN &quot; + SplitEntry.TABLE_NAME + &quot; ON &quot;
                + TransactionEntry.TABLE_NAME + &quot;.&quot; + TransactionEntry.COLUMN_UID + &quot; = &quot;
                + SplitEntry.TABLE_NAME + &quot;.&quot; + SplitEntry.COLUMN_TRANSACTION_UID);
<span class="nc" id="L526">        queryBuilder.setDistinct(true);</span>
<span class="nc" id="L527">        String[] projectionIn = new String[]{TransactionEntry.TABLE_NAME + &quot;.*&quot;};</span>
<span class="nc" id="L528">        String selection = &quot;(&quot; + SplitEntry.TABLE_NAME + &quot;.&quot; + SplitEntry.COLUMN_ACCOUNT_UID + &quot; = ?&quot;</span>
                + &quot; OR &quot; + TransactionEntry.TABLE_NAME + &quot;.&quot; + TransactionEntry.COLUMN_TEMPLATE + &quot;=1 )&quot;
                + &quot; AND &quot; + TransactionEntry.TABLE_NAME + &quot;.&quot; + TransactionEntry.COLUMN_DESCRIPTION + &quot; LIKE '&quot; + prefix + &quot;%'&quot;;
<span class="nc" id="L531">        String[] selectionArgs = new String[]{accountUID};</span>
<span class="nc" id="L532">        String sortOrder = TransactionEntry.TABLE_NAME + &quot;.&quot; + TransactionEntry.COLUMN_TIMESTAMP + &quot; DESC&quot;;</span>
<span class="nc" id="L533">        String groupBy = TransactionEntry.COLUMN_DESCRIPTION;</span>
<span class="nc" id="L534">        String limit = Integer.toString(5);</span>

<span class="nc" id="L536">        return queryBuilder.query(mDb, projectionIn, selection, selectionArgs, groupBy, null, sortOrder, limit);</span>
    }

    /**
     * Updates a specific entry of an transaction
     * @param contentValues Values with which to update the record
     * @param whereClause Conditions for updating formatted as SQL where statement
     * @param whereArgs Arguments for the SQL wehere statement
     * @return Number of records affected
     */
    public int updateTransaction(ContentValues contentValues, String whereClause, String[] whereArgs){
<span class="nc" id="L547">        return mDb.update(TransactionEntry.TABLE_NAME, contentValues, whereClause, whereArgs);</span>
    }

    /**
     * Return the number of currencies used in the transaction.
     * For example if there are different splits with different currencies
     * @param transactionUID GUID of the transaction
     * @return Number of currencies within the transaction
     */
    public int getNumCurrencies(String transactionUID) {
<span class="nc" id="L557">        Cursor cursor = mDb.query(&quot;trans_extra_info&quot;,</span>
                new String[]{&quot;trans_currency_count&quot;},
                &quot;trans_acct_t_uid=?&quot;,
                new String[]{transactionUID},
                null, null, null);
<span class="nc" id="L562">        int numCurrencies = 0;</span>
        try {
<span class="nc bnc" id="L564" title="All 2 branches missed.">            if (cursor.moveToFirst()) {</span>
<span class="nc" id="L565">                numCurrencies = cursor.getInt(0);</span>
            }
        }
        finally {
<span class="nc" id="L569">            cursor.close();</span>
<span class="nc" id="L570">        }</span>
<span class="nc" id="L571">        return numCurrencies;</span>
    }

    /**
     * Deletes all transactions except those which are marked as templates.
     * &lt;p&gt;If you want to delete really all transaction records, use {@link #deleteAllRecords()}&lt;/p&gt;
     * @return Number of records deleted
     */
    public int deleteAllNonTemplateTransactions(){
<span class="nc" id="L580">        String where = TransactionEntry.COLUMN_TEMPLATE + &quot;=0&quot;;</span>
<span class="nc" id="L581">        return mDb.delete(mTableName, where, null);</span>
    }

    /**
     * Returns a timestamp of the earliest transaction for a specified account type and currency
     * @param type the account type
     * @param currencyCode the currency code
     * @return the earliest transaction's timestamp. Returns 1970-01-01 00:00:00.000 if no transaction found
     */
    public long getTimestampOfEarliestTransaction(AccountType type, String currencyCode) {
<span class="nc" id="L591">        return getTimestamp(&quot;MIN&quot;, type, currencyCode);</span>
    }

    /**
     * Returns a timestamp of the latest transaction for a specified account type and currency
     * @param type the account type
     * @param currencyCode the currency code
     * @return the latest transaction's timestamp. Returns 1970-01-01 00:00:00.000 if no transaction found
     */
    public long getTimestampOfLatestTransaction(AccountType type, String currencyCode) {
<span class="nc" id="L601">        return getTimestamp(&quot;MAX&quot;, type, currencyCode);</span>
    }

    /**
     * Returns the most recent `modified_at` timestamp of non-template transactions in the database
     * @return Last moodified time in milliseconds or current time if there is none in the database
     */
    public Timestamp getTimestampOfLastModification(){
<span class="nc" id="L609">        Cursor cursor = mDb.query(TransactionEntry.TABLE_NAME,</span>
                new String[]{&quot;MAX(&quot; + TransactionEntry.COLUMN_MODIFIED_AT + &quot;)&quot;},
                null, null, null, null, null);

<span class="nc" id="L613">        Timestamp timestamp = TimestampHelper.getTimestampFromNow();</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">        if (cursor.moveToFirst()){</span>
<span class="nc" id="L615">            String timeString = cursor.getString(0);</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">            if (timeString != null){ //in case there were no transactions in the XML file (account structure only)</span>
<span class="nc" id="L617">                timestamp = TimestampHelper.getTimestampFromUtcString(timeString);</span>
            }
        }
<span class="nc" id="L620">        cursor.close();</span>
<span class="nc" id="L621">        return timestamp;</span>
    }

    /**
     * Returns the earliest or latest timestamp of transactions for a specific account type and currency
     * @param mod Mode (either MAX or MIN)
     * @param type AccountType
     * @param currencyCode the currency code
     * @return earliest or latest timestamp of transactions
     * @see #getTimestampOfLatestTransaction(AccountType, String)
     * @see #getTimestampOfEarliestTransaction(AccountType, String)
     */
    private long getTimestamp(String mod, AccountType type, String currencyCode) {
<span class="nc" id="L634">        String sql = &quot;SELECT &quot; + mod + &quot;(&quot; + TransactionEntry.COLUMN_TIMESTAMP + &quot;)&quot;</span>
                + &quot; FROM &quot; + TransactionEntry.TABLE_NAME
                + &quot; INNER JOIN &quot; + SplitEntry.TABLE_NAME + &quot; ON &quot;
                + SplitEntry.TABLE_NAME + &quot;.&quot; + SplitEntry.COLUMN_TRANSACTION_UID + &quot; = &quot;
                + TransactionEntry.TABLE_NAME + &quot;.&quot; + TransactionEntry.COLUMN_UID
                + &quot; INNER JOIN &quot; + AccountEntry.TABLE_NAME + &quot; ON &quot;
                + AccountEntry.TABLE_NAME + &quot;.&quot; + AccountEntry.COLUMN_UID + &quot; = &quot;
                + SplitEntry.TABLE_NAME + &quot;.&quot; + SplitEntry.COLUMN_ACCOUNT_UID
                + &quot; WHERE &quot; + AccountEntry.TABLE_NAME + &quot;.&quot; + AccountEntry.COLUMN_TYPE + &quot; = ? AND &quot;
                + TransactionEntry.TABLE_NAME + &quot;.&quot; + TransactionEntry.COLUMN_CURRENCY + &quot; = ? AND &quot;
                + TransactionEntry.TABLE_NAME + &quot;.&quot; + TransactionEntry.COLUMN_TEMPLATE + &quot; = 0&quot;;
<span class="nc" id="L645">        Cursor cursor = mDb.rawQuery(sql, new String[]{ type.name(), currencyCode });</span>
<span class="nc" id="L646">        long timestamp= 0;</span>
<span class="nc bnc" id="L647" title="All 2 branches missed.">        if (cursor != null) {</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">            if (cursor.moveToFirst()) {</span>
<span class="nc" id="L649">                timestamp = cursor.getLong(0);</span>
            }
<span class="nc" id="L651">            cursor.close();</span>
        }
<span class="nc" id="L653">        return timestamp;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>